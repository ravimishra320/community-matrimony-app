# ðŸš€ Community-Specific Matrimony App: Serverless-First on AWS

## Status
**Development Phase:** MVP - Sprint 1 (Foundation) & 2 (Identity) in Progress
**Architecture:** Serverless (AWS)
**Database:** PostgreSQL/JSONB

## ðŸ’¡ Architecture Overview: Serverless-First Approach

This project adopts a **Serverless-First** architecture on AWS. This strategy is ideal for a startup due to its pay-as-you-go model (zero cost when idle) and automatic, consumption-based scaling.

### The Core Stack

| Component | Technology | Purpose |
| :--- | :--- | :--- |
| **Frontend** | **React Native** (with Expo) | Cross-platform mobile development (fast speed to market). |
| **Backend Compute** | **AWS Lambda** (Node.js/TypeScript) | Event-driven, scalable execution of business logic. |
| **API Layer** | **AWS API Gateway** (REST API) | Secure, high-performance entry point for all API requests. |
| **Database** | **AWS Aurora Serverless v2** (PostgreSQL) | Relational data with flexible schema support via **JSONB**. |
| **Authentication** | **AWS Cognito** | User pools for phone number/OTP authentication. |
| **File Storage** | **AWS S3** | Private, secure storage for profile photos and ID proofs. |
| **Notifications** | AWS Pinpoint or SNS | Push notifications for interests/requests. |

---

## ðŸ’» High-Level Design & Data Flow

1.  **User Identity:** React Native app authenticates via **AWS Cognito** (Phone Number/OTP), which issues a JWT.
2.  **API Requests:** App sends requests to **API Gateway**.
3.  **Security:** API Gateway validates the JWT against Cognito.
4.  **Business Logic:** API Gateway triggers a specific **AWS Lambda** function.
5.  **Data Access:** Lambda queries **Aurora Serverless (PostgreSQL)**.
6.  **Media Upload:** Profile photos are uploaded directly from React Native to **S3** using pre-signed URLs generated by Lambda, reducing server load.

---

## ðŸ› ï¸ AWS Backend Design: The "Community" Logic

The design utilizes PostgreSQL's `JSONB` support to handle the flexible and evolving requirements of community-specific cultural data (e.g., *Gotra*, *Kuldevta*, *Diet*).

### Lambda Functions Structure (Microservices Approach)

| Service | Key Functions | Description |
| :--- | :--- | :--- |
| **Auth Service** | `auth-pre-signup`, `auth-post-confirmation` | Handles user invitation validation and initial DB record creation. |
| **Profile Service** | `get-profile`, `update-profile` | Fetches and updates user data; includes **Verification Trigger** for ID uploads. |
| **Match Service (Core)** | `get-recommendations` | Runs core exclusion logic (e.g., No Same-Gotra filter). |
| **Interest Service** | `send-interest`, `get-requests` | Manages user interactions (Connect/Like). |

### API Flow: The "Exogamy" (No Same-Gotra) Search

The core recommendation logic is implemented directly in the Lambda function to enforce the community rule of not showing profiles with the same *Gotra*.

**Endpoint:** `GET /matches/recommendations`

```typescript
export const handler = async (event) => {
  const userId = event.requestContext.authorizer.claims.sub;

  // 1. Fetch current user's Gotra
  const currentUser = await db.query(
    "SELECT community_data->>'gotra' as my_gotra, gender FROM profiles WHERE user_id = $1", 
    [userId]
  );
  const { my_gotra, gender } = currentUser.rows[0];

  // 2. Search for opposite gender & EXCLUDE same Gotra
  const query = `
    SELECT * FROM profiles 
    WHERE gender != $1 
    AND community_data->>'gotra' != $2 -- The Exogamy Rule
    AND account_status = 'ACTIVE'
    LIMIT 20
  `;

  const matches = await db.query(query, [gender, my_gotra]);
  
  return { statusCode: 200, body: JSON.stringify(matches.rows) };
};
